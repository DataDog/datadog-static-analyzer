commit a177ccc81b73af153083fe481768059cab6226e9
Author: Arthur Belleville <arthur.belleville@datadoghq.com>
Date:   Wed Apr 16 17:36:13 2025 +0200

    try

diff --git a/Cargo.lock b/Cargo.lock
index f2ec3cc..7b62789 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -734,7 +734,7 @@ dependencies = [
 [[package]]
 name = "dd-sds"
 version = "0.1.2"
-source = "git+https://github.com/DataDog/dd-sensitive-data-scanner.git?rev=1d03f4d0ce9f0d089fec4c6b94e6f855836f52ec#1d03f4d0ce9f0d089fec4c6b94e6f855836f52ec"
+source = "git+https://github.com/DataDog/dd-sensitive-data-scanner.git?rev=6f933121394d7d0fe62f58065623cba657f7bb5d#6f933121394d7d0fe62f58065623cba657f7bb5d"
 dependencies = [
  "ahash",
  "async-trait",
diff --git a/crates/cli/src/model/datadog_api.rs b/crates/cli/src/model/datadog_api.rs
index 4908886..ca8f4bd 100644
--- a/crates/cli/src/model/datadog_api.rs
+++ b/crates/cli/src/model/datadog_api.rs
@@ -7,7 +7,7 @@ use secrets::model::secret_rule::{
     SecretRuleMatchValidationHttpCode, SecretRuleMatchValidationHttpMethod,
 };
 use serde::{Deserialize, Serialize};
-use std::collections::HashMap;
+use std::collections::BTreeMap;
 
 // Data for diff-aware scanning
 #[derive(Serialize, Deserialize, Debug, Clone)]
@@ -292,7 +292,7 @@ pub struct SecretRuleApiMatchValidation {
     pub r#type: String,
     pub endpoint: Option<String>,
     pub hosts: Option<Vec<String>>,
-    pub request_headers: Option<HashMap<String, String>>,
+    pub request_headers: Option<BTreeMap<String, String>>,
     pub http_method: Option<SecretRuleApiMatchValidationHttpMethod>,
     pub timeout_seconds: Option<u64>,
     pub valid_http_status_code: Option<Vec<SecretRuleApiMatchValidationHttpCode>>,
diff --git a/crates/secrets/Cargo.toml b/crates/secrets/Cargo.toml
index 9a32917..ea5c317 100644
--- a/crates/secrets/Cargo.toml
+++ b/crates/secrets/Cargo.toml
@@ -15,4 +15,4 @@ futures = "0.3.31"
 lazy_static = "1.5.0"
 
 # remote
-dd-sds = { git = "https://github.com/DataDog/dd-sensitive-data-scanner.git", rev = "1d03f4d0ce9f0d089fec4c6b94e6f855836f52ec" }
+dd-sds = { git = "https://github.com/DataDog/dd-sensitive-data-scanner.git", rev = "6f933121394d7d0fe62f58065623cba657f7bb5d" }
diff --git a/crates/secrets/src/model/secret_rule.rs b/crates/secrets/src/model/secret_rule.rs
index e1910a5..4d0099d 100644
--- a/crates/secrets/src/model/secret_rule.rs
+++ b/crates/secrets/src/model/secret_rule.rs
@@ -6,14 +6,11 @@ use crate::model::secret_rule::SecretRuleMatchValidation::CustomHttp;
 use common::model::diff_aware::DiffAware;
 use dd_sds::SecondaryValidator::JwtExpirationChecker;
 use dd_sds::{
-    AwsConfig, AwsType, HttpMethod, HttpValidatorConfigBuilder, MatchAction, MatchValidationType,
-    ProximityKeywordsConfig, RegexRuleConfig, RequestHeader,
+    AwsConfig, AwsType, CustomHttpConfig, HttpMethod, HttpStatusCodeRange, MatchAction,
+    MatchValidationType, ProximityKeywordsConfig, RegexRuleConfig, RootRuleConfig,
 };
 use serde::{Deserialize, Serialize};
-use std::collections::HashMap;
-use std::ops::Range;
-use std::string::ToString;
-use std::time::Duration;
+use std::collections::BTreeMap;
 
 const DEFAULT_LOOK_AHEAD_CHARACTER_COUNT: usize = 30;
 
@@ -66,33 +63,31 @@ impl TryFrom<&SecretRuleMatchValidation> for MatchValidationType {
                 Ok(MatchValidationType::Aws(AwsType::AwsSession))
             }
             CustomHttp(custom_http) => {
-                let invalid_ports: Vec<Range<u16>> = custom_http
+                let invalid_ports: Vec<HttpStatusCodeRange> = custom_http
                     .invalid_http_status_code
                     .iter()
-                    .map(|v| Range {
+                    .map(|v| HttpStatusCodeRange {
                         start: v.start,
                         end: v.end,
                     })
                     .collect();
-                let valid_ports: Vec<Range<u16>> = custom_http
+                let valid_ports: Vec<HttpStatusCodeRange> = custom_http
                     .valid_http_status_code
                     .iter()
-                    .map(|v| Range {
+                    .map(|v| HttpStatusCodeRange {
                         start: v.start,
                         end: v.end,
                     })
                     .collect();
-                Ok(MatchValidationType::CustomHttp(
-                    HttpValidatorConfigBuilder::new(custom_http.endpoint.clone())
-                        .set_hosts(custom_http.clone().hosts)
-                        .set_invalid_http_status_code(invalid_ports)
-                        .set_timeout(Duration::from_secs(custom_http.timeout_seconds.unwrap()))
-                        .set_request_header(custom_http.get_request_headers())
-                        .set_valid_http_status_code(valid_ports)
-                        .set_method(custom_http.http_method.into())
-                        .build()
-                        .unwrap(),
-                ))
+                Ok(MatchValidationType::CustomHttp(CustomHttpConfig {
+                    endpoint: custom_http.endpoint.clone(),
+                    hosts: custom_http.hosts.clone(),
+                    http_method: custom_http.http_method.into(),
+                    request_headers: custom_http.request_headers.clone(),
+                    valid_http_status_code: valid_ports,
+                    invalid_http_status_code: invalid_ports,
+                    timeout_seconds: custom_http.timeout_seconds.unwrap() as u32,
+                }))
             }
         }
     }
@@ -102,25 +97,13 @@ impl TryFrom<&SecretRuleMatchValidation> for MatchValidationType {
 pub struct SecretRuleMatchValidationHttp {
     pub endpoint: String,
     pub hosts: Vec<String>,
-    pub request_headers: HashMap<String, String>,
+    pub request_headers: BTreeMap<String, String>,
     pub http_method: SecretRuleMatchValidationHttpMethod,
     pub timeout_seconds: Option<u64>,
     pub valid_http_status_code: Vec<SecretRuleMatchValidationHttpCode>,
     pub invalid_http_status_code: Vec<SecretRuleMatchValidationHttpCode>,
 }
 
-impl SecretRuleMatchValidationHttp {
-    pub fn get_request_headers(&self) -> Vec<RequestHeader> {
-        self.request_headers
-            .iter()
-            .map(|(k, v)| RequestHeader {
-                key: k.clone(),
-                value: v.clone(),
-            })
-            .collect()
-    }
-}
-
 // This is the secret rule exposed by SDS
 #[derive(Clone, Deserialize, Debug, Serialize, Eq, PartialEq)]
 pub struct SecretRule {
@@ -137,15 +120,16 @@ impl SecretRule {
     const VALIDATOR_JWT_EXPIRATION_CHECKER: &'static str = "JwtExpirationChecker";
 
     /// Convert the rule into a configuration usable by SDS.
-    pub fn convert_to_sds_ruleconfig(&self, use_debug: bool) -> RegexRuleConfig {
-        let mut rule_config = RegexRuleConfig::new(&self.pattern).match_action(MatchAction::None);
+    pub fn convert_to_sds_ruleconfig(&self, use_debug: bool) -> RootRuleConfig<RegexRuleConfig> {
+        let mut regex_rule_config = RegexRuleConfig::new(&self.pattern);
 
         if !self.default_included_keywords.is_empty() {
-            rule_config = rule_config.proximity_keywords(ProximityKeywordsConfig {
-                look_ahead_character_count: DEFAULT_LOOK_AHEAD_CHARACTER_COUNT,
-                included_keywords: self.default_included_keywords.clone(),
-                excluded_keywords: vec![],
-            });
+            regex_rule_config =
+                regex_rule_config.with_proximity_keywords(ProximityKeywordsConfig {
+                    look_ahead_character_count: DEFAULT_LOOK_AHEAD_CHARACTER_COUNT,
+                    included_keywords: self.default_included_keywords.clone(),
+                    excluded_keywords: vec![],
+                });
         }
 
         if let Some(validators) = &self.validators {
@@ -153,13 +137,16 @@ impl SecretRule {
                 .iter()
                 .any(|v| v == SecretRule::VALIDATOR_JWT_EXPIRATION_CHECKER)
             {
-                rule_config = rule_config.validator(JwtExpirationChecker);
+                regex_rule_config = regex_rule_config.with_validator(Some(JwtExpirationChecker));
             }
         }
 
+        let mut rule_config =
+            RootRuleConfig::new(regex_rule_config).match_action(MatchAction::None);
+
         if let Some(match_validation) = &self.match_validation {
             if let Ok(mvt) = match_validation.try_into() {
-                rule_config = rule_config.match_validation_type(mvt);
+                rule_config = rule_config.third_party_active_checker(mvt);
             } else if use_debug {
                 eprintln!("invalid validation: {:?}", match_validation);
             }
diff --git a/crates/secrets/src/scanner.rs b/crates/secrets/src/scanner.rs
index 961dba5..b5540dd 100644
--- a/crates/secrets/src/scanner.rs
+++ b/crates/secrets/src/scanner.rs
@@ -8,7 +8,7 @@ use anyhow::Error;
 use common::analysis_options::AnalysisOptions;
 use common::model::position::Position;
 use common::utils::position_utils::get_position_in_string;
-use dd_sds::{RuleConfig, Scanner};
+use dd_sds::{RootRuleConfig, RuleConfig, Scanner};
 use itertools::Itertools;
 use std::sync::Arc;
 
@@ -19,8 +19,8 @@ use std::sync::Arc;
 pub fn build_sds_scanner(rules: &[SecretRule], use_debug: bool) -> Scanner {
     let sds_rules = rules
         .iter()
-        .map(|r| r.convert_to_sds_ruleconfig(use_debug).build())
-        .collect::<Vec<Arc<dyn RuleConfig>>>();
+        .map(|r| r.convert_to_sds_ruleconfig(use_debug).into_dyn())
+        .collect::<Vec<RootRuleConfig<Arc<dyn RuleConfig>>>>();
     Scanner::builder(&sds_rules)
         .build()
         .expect("error when instantiating the scanner")
@@ -42,7 +42,7 @@ pub fn find_secrets(
     }
 
     let mut codemut = code.to_owned();
-    let mut matches = scanner.scan(&mut codemut, vec![]);
+    let mut matches = scanner.scan(&mut codemut);
 
     if matches.is_empty() {
         return vec![];
