/* automatically generated by rust-bindgen 0.69.4 */

pub const CH_SUCCESS: i32 = 0;
pub const CH_INVALID: i32 = -1;
pub const CH_NOMEM: i32 = -2;
pub const CH_SCAN_TERMINATED: i32 = -3;
pub const CH_COMPILER_ERROR: i32 = -4;
pub const CH_DB_VERSION_ERROR: i32 = -5;
pub const CH_DB_PLATFORM_ERROR: i32 = -6;
pub const CH_DB_MODE_ERROR: i32 = -7;
pub const CH_BAD_ALIGN: i32 = -8;
pub const CH_BAD_ALLOC: i32 = -9;
pub const CH_SCRATCH_IN_USE: i32 = -10;
pub const CH_UNKNOWN_HS_ERROR: i32 = -13;
pub const CH_FAIL_INTERNAL: i32 = -32;
pub const CH_FLAG_CASELESS: u32 = 1;
pub const CH_FLAG_DOTALL: u32 = 2;
pub const CH_FLAG_MULTILINE: u32 = 4;
pub const CH_FLAG_SINGLEMATCH: u32 = 8;
pub const CH_FLAG_UTF8: u32 = 32;
pub const CH_FLAG_UCP: u32 = 64;
pub const CH_MODE_NOGROUPS: u32 = 0;
pub const CH_MODE_GROUPS: u32 = 1048576;
pub const CH_CALLBACK_CONTINUE: u32 = 0;
pub const CH_CALLBACK_TERMINATE: u32 = 1;
pub const CH_CALLBACK_SKIP_PATTERN: u32 = 2;
pub const CH_ERROR_MATCHLIMIT: u32 = 1;
pub const CH_ERROR_RECURSIONLIMIT: u32 = 2;
pub const CH_CAPTURE_FLAG_INACTIVE: u32 = 0;
pub const CH_CAPTURE_FLAG_ACTIVE: u32 = 1;
#[doc = " A type containing information on the target platform which may optionally be\n provided to the compile calls (@ref hs_compile(), @ref hs_compile_multi(),\n @ref hs_compile_ext_multi()).\n\n A hs_platform_info structure may be populated for the current platform by\n using the @ref hs_populate_platform() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_platform_info {
    #[doc = " Information about the target platform which may be used to guide the\n optimisation process of the compile.\n\n Use of this field does not limit the processors that the resulting\n database can run on, but may impact the performance of the resulting\n database."]
    pub tune: ::core::ffi::c_uint,
    #[doc = " Relevant CPU features available on the target platform\n\n This value may be produced by combining HS_CPU_FEATURE_* flags (such as\n @ref HS_CPU_FEATURES_AVX2). Multiple CPU features may be or'ed together\n to produce the value."]
    pub cpu_features: ::core::ffi::c_ulonglong,
    #[doc = " Reserved for future use."]
    pub reserved1: ::core::ffi::c_ulonglong,
    #[doc = " Reserved for future use."]
    pub reserved2: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hs_platform_info() {
    const UNINIT: ::core::mem::MaybeUninit<hs_platform_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hs_platform_info>(),
        32usize,
        concat!("Size of: ", stringify!(hs_platform_info))
    );
    assert_eq!(
        ::core::mem::align_of::<hs_platform_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_platform_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tune) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(tune)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(cpu_features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " A type containing information on the target platform which may optionally be\n provided to the compile calls (@ref hs_compile(), @ref hs_compile_multi(),\n @ref hs_compile_ext_multi()).\n\n A hs_platform_info structure may be populated for the current platform by\n using the @ref hs_populate_platform() call."]
pub type hs_platform_info_t = hs_platform_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ch_database {
    _unused: [u8; 0],
}
#[doc = " A Chimera pattern database.\n\n Generated by one of the Chimera compiler functions:\n  - @ref ch_compile()\n  - @ref ch_compile_multi()\n  - @ref ch_compile_ext_multi()"]
pub type ch_database_t = ch_database;
#[doc = " A type for errors returned by Chimera functions."]
pub type ch_error_t = ::core::ffi::c_int;
extern "C" {
    #[must_use]
    #[doc = " Free a compiled pattern database.\n\n The free callback set by @ref ch_set_allocator()) will be used by this\n function.\n\n @param db\n      A compiled pattern database. NULL may also be safely provided, in which\n      case the function does nothing.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_free_database(db: *mut ch_database_t) -> ch_error_t;
}
extern "C" {
    #[doc = " Utility function for identifying this release version.\n\n @return\n      A string containing the version number of this release build and the\n      date of the build. It is allocated statically, so it does not need to\n      be freed by the caller."]
    pub fn ch_version() -> *const ::core::ffi::c_char;
}
extern "C" {
    #[must_use]
    #[doc = " Returns the size of the given database.\n\n @param database\n      Pointer to compiled expression database.\n\n @param database_size\n      On success, the size of the compiled database in bytes is placed in this\n      parameter.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_database_size(
        database: *const ch_database_t,
        database_size: *mut usize,
    ) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Utility function providing information about a database.\n\n @param database\n      Pointer to a compiled database.\n\n @param info\n      On success, a string containing the version and platform information for\n      the supplied database is placed in the parameter. The string is\n      allocated using the allocator supplied in @ref hs_set_allocator()\n      (or malloc() if no allocator was set) and should be freed by the caller.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_database_info(
        database: *const ch_database_t,
        info: *mut *mut ::core::ffi::c_char,
    ) -> ch_error_t;
}
#[doc = " The type of the callback function that will be used by Chimera to allocate\n more memory at runtime as required.\n\n If Chimera is to be used in a multi-threaded, or similarly concurrent\n environment, the allocation function will need to be re-entrant, or\n similarly safe for concurrent use.\n\n @param size\n      The number of bytes to allocate.\n @return\n      A pointer to the region of memory allocated, or NULL on error."]
pub type ch_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>;
#[doc = " The type of the callback function that will be used by Chimera to free\n memory regions previously allocated using the @ref ch_alloc_t function.\n\n @param ptr\n      The region of memory to be freed."]
pub type ch_free_t = ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>;
extern "C" {
    #[must_use]
    #[doc = " Set the allocate and free functions used by Chimera for allocating\n memory at runtime for stream state, scratch space, database bytecode,\n and various other data structure returned by the Chimera API.\n\n The function is equivalent to calling @ref ch_set_scratch_allocator(),\n @ref ch_set_database_allocator() and\n @ref ch_set_misc_allocator() with the provided parameters.\n\n This call will override any previous allocators that have been set.\n\n Note: there is no way to change the allocator used for temporary objects\n created during the various compile calls (@ref ch_compile() and @ref\n ch_compile_multi()).\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_set_allocator(alloc_func: ch_alloc_t, free_func: ch_free_t) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Set the allocate and free functions used by Chimera for allocating memory\n for database bytecode produced by the compile calls (@ref ch_compile() and @ref\n ch_compile_multi()).\n\n If no database allocation functions are set, or if NULL is used in place of\n both parameters, then memory allocation will default to standard methods\n (such as the system malloc() and free() calls).\n\n This call will override any previous database allocators that have been set.\n\n Note: the database allocator may also be set by calling @ref\n ch_set_allocator().\n\n Note: there is no way to change how temporary objects created during the\n various compile calls (@ref ch_compile() and @ref ch_compile_multi()) are\n allocated.\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn ch_set_database_allocator(alloc_func: ch_alloc_t, free_func: ch_free_t) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Set the allocate and free functions used by Chimera for allocating memory\n for items returned by the Chimera API such as @ref ch_compile_error_t.\n\n If no misc allocation functions are set, or if NULL is used in place of both\n parameters, then memory allocation will default to standard methods (such as\n the system malloc() and free() calls).\n\n This call will override any previous misc allocators that have been set.\n\n Note: the misc allocator may also be set by calling @ref ch_set_allocator().\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_set_misc_allocator(alloc_func: ch_alloc_t, free_func: ch_free_t) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Set the allocate and free functions used by Chimera for allocating memory\n for scratch space by @ref ch_alloc_scratch() and @ref ch_clone_scratch().\n\n If no scratch allocation functions are set, or if NULL is used in place of\n both parameters, then memory allocation will default to standard methods\n (such as the system malloc() and free() calls).\n\n This call will override any previous scratch allocators that have been set.\n\n Note: the scratch allocator may also be set by calling @ref\n ch_set_allocator().\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_set_scratch_allocator(alloc_func: ch_alloc_t, free_func: ch_free_t) -> ch_error_t;
}
#[doc = " A type containing error details that is returned by the compile calls (@ref\n ch_compile() and @ref ch_compile_multi() on failure. The caller may inspect\n the values returned in this type to determine the cause of failure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ch_compile_error {
    #[doc = " A human-readable error message describing the error."]
    pub message: *mut ::core::ffi::c_char,
    #[doc = " The zero-based number of the expression that caused the error (if this\n can be determined). If the error is not specific to an expression, then\n this value will be less than zero."]
    pub expression: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_ch_compile_error() {
    const UNINIT: ::core::mem::MaybeUninit<ch_compile_error> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ch_compile_error>(),
        16usize,
        concat!("Size of: ", stringify!(ch_compile_error))
    );
    assert_eq!(
        ::core::mem::align_of::<ch_compile_error>(),
        8usize,
        concat!("Alignment of ", stringify!(ch_compile_error))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ch_compile_error),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expression) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ch_compile_error),
            "::",
            stringify!(expression)
        )
    );
}
#[doc = " A type containing error details that is returned by the compile calls (@ref\n ch_compile() and @ref ch_compile_multi() on failure. The caller may inspect\n the values returned in this type to determine the cause of failure."]
pub type ch_compile_error_t = ch_compile_error;
extern "C" {
    #[must_use]
    #[doc = " The basic regular expression compiler.\n\n This is the function call with which an expression is compiled into a\n Chimera database which can be passed to the runtime function (\n @ref ch_scan())\n\n @param expression\n      The NULL-terminated expression to parse. Note that this string must\n      represent ONLY the pattern to be matched, with no delimiters or flags;\n      any global flags should be specified with the @a flags argument. For\n      example, the expression `/abc?def/i` should be compiled by providing\n      `abc?def` as the @a expression, and @ref CH_FLAG_CASELESS as the @a\n      flags.\n\n @param flags\n      Flags which modify the behaviour of the expression. Multiple flags may\n      be used by ORing them together. Valid values are:\n       - CH_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - CH_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - CH_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - CH_FLAG_SINGLEMATCH - Only one match will be generated for the\n                               expression per stream.\n       - CH_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - CH_FLAG_UCP - Use Unicode properties for character classes.\n\n @param mode\n      Compiler mode flag that affect the database as a whole for capturing\n      groups. One of  CH_MODE_NOGROUPS or  CH_MODE_GROUPS must be supplied.\n      See @ref CH_MODE_FLAG for more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref ch_free_database() function.\n\n @param compile_error\n      If the compile fails, a pointer to a @ref ch_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      ch_free_compile_error() function.\n\n @return\n      @ref CH_SUCCESS is returned on successful compilation; @ref\n      CH_COMPILER_ERROR on failure, with details provided in the error\n      parameter."]
    pub fn ch_compile(
        expression: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_uint,
        mode: ::core::ffi::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut ch_database_t,
        compile_error: *mut *mut ch_compile_error_t,
    ) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " The multiple regular expression compiler.\n\n This is the function call with which a set of expressions is compiled into a\n database which can be passed to the runtime function (@ref ch_scan()).\n Each expression can be labelled with a unique integer which is passed into\n the match callback to identify the pattern that has matched.\n\n @param expressions\n      Array of NULL-terminated expressions to compile. Note that (as for @ref\n      ch_compile()) these strings must contain only the pattern to be\n      matched, with no delimiters or flags. For example, the expression\n      `/abc?def/i` should be compiled by providing `abc?def` as the first\n      string in the @a expressions array, and @ref CH_FLAG_CASELESS as the\n      first value in the @a flags array.\n\n @param flags\n      Array of flags which modify the behaviour of each expression. Multiple\n      flags may be used by ORing them together.  Specifying the NULL pointer\n      in place of an array will set the flags value for all patterns to zero.\n      Valid values are:\n       - CH_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - CH_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - CH_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - CH_FLAG_SINGLEMATCH - Only one match will be generated by patterns\n                               with this match id per stream.\n       - CH_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - CH_FLAG_UCP - Use Unicode properties for character classes.\n\n @param ids\n      An array of integers specifying the ID number to be associated with the\n      corresponding pattern in the expressions array. Specifying the NULL\n      pointer in place of an array will set the ID value for all patterns to\n      zero.\n\n @param elements\n      The number of elements in the input arrays.\n\n @param mode\n      Compiler mode flag that affect the database as a whole for capturing\n      groups. One of  CH_MODE_NOGROUPS or  CH_MODE_GROUPS must be supplied.\n      See @ref CH_MODE_FLAG for more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref ch_free_database() function.\n\n @param compile_error\n      If the compile fails, a pointer to a @ref ch_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      ch_free_compile_error() function.\n\n @return\n      @ref CH_SUCCESS is returned on successful compilation; @ref\n      CH_COMPILER_ERROR on failure, with details provided in the @a error\n      parameter.\n"]
    pub fn ch_compile_multi(
        expressions: *const *const ::core::ffi::c_char,
        flags: *const ::core::ffi::c_uint,
        ids: *const ::core::ffi::c_uint,
        elements: ::core::ffi::c_uint,
        mode: ::core::ffi::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut ch_database_t,
        compile_error: *mut *mut ch_compile_error_t,
    ) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " The multiple regular expression compiler with extended match limits support.\n\n This is the function call with which a set of expressions is compiled into a\n database in the same way as @ref ch_compile_multi(), but allows additional\n parameters to be specified via match_limit and match_limit_recursion to\n define match limits for PCRE runtime.\n\n @param expressions\n      Array of NULL-terminated expressions to compile. Note that (as for @ref\n      ch_compile()) these strings must contain only the pattern to be\n      matched, with no delimiters or flags. For example, the expression\n      `/abc?def/i` should be compiled by providing `abc?def` as the first\n      string in the @a expressions array, and @ref CH_FLAG_CASELESS as the\n      first value in the @a flags array.\n\n @param flags\n      Array of flags which modify the behaviour of each expression. Multiple\n      flags may be used by ORing them together.  Specifying the NULL pointer\n      in place of an array will set the flags value for all patterns to zero.\n      Valid values are:\n       - CH_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - CH_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - CH_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - CH_FLAG_SINGLEMATCH - Only one match will be generated by patterns\n                               with this match id per stream.\n       - CH_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - CH_FLAG_UCP - Use Unicode properties for character classes.\n\n @param ids\n      An array of integers specifying the ID number to be associated with the\n      corresponding pattern in the expressions array. Specifying the NULL\n      pointer in place of an array will set the ID value for all patterns to\n      zero.\n\n @param elements\n      The number of elements in the input arrays.\n\n @param mode\n      Compiler mode flag that affect the database as a whole for capturing\n      groups. One of  CH_MODE_NOGROUPS or  CH_MODE_GROUPS must be supplied.\n      See @ref CH_MODE_FLAG for more details.\n\n @param match_limit\n      A limit from pcre_extra on the amount of match function called in PCRE\n      to limit backtracking that can take place.\n\n @param match_limit_recursion\n      A limit from pcre_extra on the recursion depth of match function\n      in PCRE.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref ch_free_database() function.\n\n @param compile_error\n      If the compile fails, a pointer to a @ref ch_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      ch_free_compile_error() function.\n\n @return\n      @ref CH_SUCCESS is returned on successful compilation; @ref\n      CH_COMPILER_ERROR on failure, with details provided in the @a error\n      parameter.\n"]
    pub fn ch_compile_ext_multi(
        expressions: *const *const ::core::ffi::c_char,
        flags: *const ::core::ffi::c_uint,
        ids: *const ::core::ffi::c_uint,
        elements: ::core::ffi::c_uint,
        mode: ::core::ffi::c_uint,
        match_limit: ::core::ffi::c_ulong,
        match_limit_recursion: ::core::ffi::c_ulong,
        platform: *const hs_platform_info_t,
        db: *mut *mut ch_database_t,
        compile_error: *mut *mut ch_compile_error_t,
    ) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Free an error structure generated by @ref ch_compile(), @ref\n ch_compile_multi().\n\n @param error\n      The @ref ch_compile_error_t to be freed. NULL may also be safely\n      provided.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_free_compile_error(error: *mut ch_compile_error_t) -> ch_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ch_scratch {
    _unused: [u8; 0],
}
#[doc = " A Chimera scratch space."]
pub type ch_scratch_t = ch_scratch;
#[doc = " Callback return value used to tell the Chimera matcher what to do after\n processing this match."]
pub type ch_callback_t = ::core::ffi::c_int;
#[doc = " Type used to differentiate the errors raised with the @ref\n ch_error_event_handler callback."]
pub type ch_error_event_t = ::core::ffi::c_int;
#[doc = " Structure representing a captured subexpression within a match. An array of\n these structures corresponding to capture groups in order is passed to the\n callback on match, with active structures identified by the\n CH_CAPTURE_FLAG_ACTIVE flag."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ch_capture {
    #[doc = " The flags indicating if this structure is active."]
    pub flags: ::core::ffi::c_uint,
    #[doc = " offset at which this capture group begins."]
    pub from: ::core::ffi::c_ulonglong,
    #[doc = " offset at which this capture group ends."]
    pub to: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ch_capture() {
    const UNINIT: ::core::mem::MaybeUninit<ch_capture> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ch_capture>(),
        24usize,
        concat!("Size of: ", stringify!(ch_capture))
    );
    assert_eq!(
        ::core::mem::align_of::<ch_capture>(),
        8usize,
        concat!("Alignment of ", stringify!(ch_capture))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ch_capture),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ch_capture),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ch_capture),
            "::",
            stringify!(to)
        )
    );
}
#[doc = " Structure representing a captured subexpression within a match. An array of\n these structures corresponding to capture groups in order is passed to the\n callback on match, with active structures identified by the\n CH_CAPTURE_FLAG_ACTIVE flag."]
pub type ch_capture_t = ch_capture;
#[doc = " Definition of the match event callback function type.\n\n A callback function matching the defined type must be provided by the\n application calling the @ref ch_scan()\n\n This callback function will be invoked whenever a match is located in the\n target data during the execution of a scan. The details of the match are\n passed in as parameters to the callback function, and the callback function\n should return a value indicating whether or not matching should continue on\n the target data. If no callbacks are desired from a scan call, NULL may be\n provided in order to suppress match production.\n\n @param id\n      The ID number of the expression that matched. If the expression was a\n      single expression compiled with @ref ch_compile(), this value will be\n      zero.\n\n @param from\n      The offset of the first byte that matches the expression.\n\n @param to\n      The offset after the last byte that matches the expression.\n\n @param flags\n      This is provided for future use and is unused at present.\n\n @param size\n      The number of valid entries pointed to by the captured parameter.\n\n @param captured\n      A pointer to an array of @ref ch_capture_t structures that\n      contain the start and end offsets of entire pattern match and\n      each captured subexpression.\n\n @param ctx\n      The pointer supplied by the user to the @ref ch_scan() function.\n\n @return\n      The callback can return @ref CH_CALLBACK_TERMINATE to stop matching.\n      Otherwise, a return value of @ref CH_CALLBACK_CONTINUE will continue,\n      with the current pattern if configured to produce multiple matches per\n      pattern, while a return value of @ref CH_CALLBACK_SKIP_PATTERN will\n      cease matching this pattern but continue matching the next pattern."]
pub type ch_match_event_handler = ::core::option::Option<
    unsafe extern "C" fn(
        id: ::core::ffi::c_uint,
        from: ::core::ffi::c_ulonglong,
        to: ::core::ffi::c_ulonglong,
        flags: ::core::ffi::c_uint,
        size: ::core::ffi::c_uint,
        captured: *const ch_capture_t,
        ctx: *mut ::core::ffi::c_void,
    ) -> ch_callback_t,
>;
#[doc = " Definition of the Chimera error event callback function type.\n\n A callback function matching the defined type may be provided by the\n application calling the @ref ch_scan function. This callback function\n will be invoked when an error event occurs during matching; this indicates\n that some matches for a given expression may not be reported.\n\n @param error_type\n      The type of error event that occurred. Currently these errors\n      correspond to resource limits on PCRE backtracking\n      @ref CH_ERROR_MATCHLIMIT and @ref CH_ERROR_RECURSIONLIMIT.\n\n @param id\n      The ID number of the expression that matched.\n\n @param info\n      Event-specific data, for future use. Currently unused.\n\n @param ctx\n      The context pointer supplied by the user to the @ref ch_scan\n      function.\n\n @return\n      The callback can return @ref CH_CALLBACK_SKIP_PATTERN to cease matching\n      this pattern but continue matching the next pattern. Otherwise, we stop\n      matching for all patterns with @ref CH_CALLBACK_TERMINATE."]
pub type ch_error_event_handler = ::core::option::Option<
    unsafe extern "C" fn(
        error_type: ch_error_event_t,
        id: ::core::ffi::c_uint,
        info: *mut ::core::ffi::c_void,
        ctx: *mut ::core::ffi::c_void,
    ) -> ch_callback_t,
>;
extern "C" {
    #[must_use]
    #[doc = " The block regular expression scanner.\n\n This is the function call in which the actual pattern matching takes place\n for block-mode pattern databases.\n\n @param db\n      A compiled pattern database.\n\n @param data\n      Pointer to the data to be scanned.\n\n @param length\n      The number of bytes to scan.\n\n @param flags\n      Flags modifying the behaviour of this function. This parameter is\n      provided for future use and is unused at present.\n\n @param scratch\n      A per-thread scratch space allocated by @ref ch_alloc_scratch() for this\n      database.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param onError\n      Pointer to a error event callback function. If a NULL pointer is given,\n      @ref CH_ERROR_MATCHLIMIT and @ref CH_ERROR_RECURSIONLIMIT errors will\n      be ignored and match will continue.\n\n @param context\n      The user defined pointer which will be passed to the callback function.\n\n @return\n      Returns @ref CH_SUCCESS on success; @ref CH_SCAN_TERMINATED if the\n      match callback indicated that scanning should stop; other values on\n      error."]
    pub fn ch_scan(
        db: *const ch_database_t,
        data: *const ::core::ffi::c_char,
        length: ::core::ffi::c_uint,
        flags: ::core::ffi::c_uint,
        scratch: *mut ch_scratch_t,
        onEvent: ch_match_event_handler,
        onError: ch_error_event_handler,
        context: *mut ::core::ffi::c_void,
    ) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Allocate a \"scratch\" space for use by Chimera.\n\n This is required for runtime use, and one scratch space per thread, or\n concurrent caller, is required. Any allocator callback set by @ref\n ch_set_scratch_allocator() or @ref ch_set_allocator() will be used by this\n function.\n\n @param db\n      The database, as produced by @ref ch_compile().\n\n @param scratch\n      On first allocation, a pointer to NULL should be provided so a new\n      scratch can be allocated. If a scratch block has been previously\n      allocated, then a pointer to it should be passed back in to see if it\n      is valid for this database block. If a new scratch block is required,\n      the original will be freed and the new one returned, otherwise the\n      previous scratch block will be returned. On success, the scratch block\n      will be suitable for use with the provided database in addition to any\n      databases that original scratch space was suitable for.\n\n @return\n      @ref CH_SUCCESS on successful allocation; @ref CH_NOMEM if the\n      allocation fails.  Other errors may be returned if invalid parameters\n      are specified."]
    pub fn ch_alloc_scratch(
        db: *const ch_database_t,
        scratch: *mut *mut ch_scratch_t,
    ) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Allocate a scratch space that is a clone of an existing scratch space.\n\n This is useful when multiple concurrent threads will be using the same set\n of compiled databases, and another scratch space is required. Any allocator\n callback set by @ref ch_set_scratch_allocator() or @ref ch_set_allocator()\n will be used by this function.\n\n @param src\n      The existing @ref ch_scratch_t to be cloned.\n\n @param dest\n      A pointer to the new scratch space will be returned here.\n\n @return\n      @ref CH_SUCCESS on success; @ref CH_NOMEM if the allocation fails.\n      Other errors may be returned if invalid parameters are specified."]
    pub fn ch_clone_scratch(src: *const ch_scratch_t, dest: *mut *mut ch_scratch_t) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Provides the size of the given scratch space.\n\n @param scratch\n      A per-thread scratch space allocated by @ref ch_alloc_scratch() or @ref\n      ch_clone_scratch().\n\n @param scratch_size\n      On success, the size of the scratch space in bytes is placed in this\n      parameter.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_scratch_size(scratch: *const ch_scratch_t, scratch_size: *mut usize) -> ch_error_t;
}
extern "C" {
    #[must_use]
    #[doc = " Free a scratch block previously allocated by @ref ch_alloc_scratch() or @ref\n ch_clone_scratch().\n\n The free callback set by @ref ch_set_scratch_allocator() or @ref\n ch_set_allocator() will be used by this function.\n\n @param scratch\n      The scratch block to be freed. NULL may also be safely provided.\n\n @return\n      @ref CH_SUCCESS on success, other values on failure."]
    pub fn ch_free_scratch(scratch: *mut ch_scratch_t) -> ch_error_t;
}
