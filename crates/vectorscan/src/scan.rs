// Unless explicitly stated otherwise all files in this repository are licensed under the Apache License, Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2024 Datadog, Inc.

use crate::database::BlockDatabase;
use crate::error::{check_ffi_result, Error};
use crate::runtime::Scratch;
use core::ffi;
use std::hash::Hash;
use std::ops::{ControlFlow, Range};
use vectorscan_sys::hs;

/// The pattern id that Hyperscan sends to a [`hs::hs_scan`] callback when it finds a match.
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PatternId(pub u32);

impl From<u32> for PatternId {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

/// A match result, and the pattern id that triggered it.
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HsMatch {
    id: PatternId,
    // NOTE: We currently split out start_idx and end_idx because we want `Copy`, but `std::ops::Range` is not.
    // (See [RFC #3500](https://github.com/rust-lang/rfcs/pull/3550) for potential 2024 Edition "fix" for this)
    start_idx: usize,
    end_idx: usize,
}

impl HsMatch {
    pub fn pattern_id(&self) -> PatternId {
        self.id
    }
    pub fn start(&self) -> usize {
        self.start_idx
    }
    pub fn end(&self) -> usize {
        self.end_idx
    }
    pub fn as_range(&self) -> Range<usize> {
        self.start_idx..self.end_idx
    }
}

impl BlockDatabase {
    /// Synchronously scans a slice of bytes, calling the provided callback with an [HsMatch]
    pub fn scan<T, U>(&mut self, scratch: &Scratch, bytes: T, callback: Box<U>) -> Result<(), Error>
    where
        T: AsRef<[u8]>,
        U: FnMut(HsMatch) -> ControlFlow<()>,
    {
        // NOTE: scan is a mutable borrow to prevent the callback from re-calling into the database
        // to initiate another scan, which will lead to an error.
        // See: https://intel.github.io/hyperscan/dev-reference/api_files.html#c.HS_SCRATCH_IN_USE
        let raw_cb = Box::into_raw(callback);

        let hs_error = unsafe {
            hs::hs_scan(
                self.as_ptr(),
                bytes.as_ref().as_ptr() as *const ffi::c_char,
                bytes.as_ref().len() as ffi::c_uint,
                // This field is [unused by Hyperscan](https://intel.github.io/hyperscan/dev-reference/api_files.html#c.hs_scan)
                0 as ffi::c_uint,
                scratch.as_ptr(),
                Some(Self::hs_match_handler::<U>),
                raw_cb as *mut ffi::c_void,
            )
        };
        // Let Box's `drop` free memory.
        // Safety: The Hyperscan library never touches the memory this pointer dereferences to, so this
        // is the complement to the `Box::into_raw` call we made earlier.
        let _ = unsafe { Box::from_raw(raw_cb) };

        check_ffi_result(hs_error, None)?;
        Ok(())
    }

    /// The callback function passed to Hyperscan to handle an event generated by [BlockDatabase::scan]
    extern "C" fn hs_match_handler<T>(
        id: ffi::c_uint,
        from: ffi::c_ulonglong,
        to: ffi::c_ulonglong,
        _flags: ffi::c_uint,
        context: *mut ffi::c_void,
    ) -> ffi::c_int
    where
        T: FnMut(HsMatch) -> ControlFlow<()>,
    {
        // Safety: This is safe because for `hs_scan`, we passed Hyperscan the raw pointer to our boxed closure,
        // and Hyperscan just echoes this pointer back to us without touching it.
        let callback = unsafe { &mut *(context as *mut T) };

        let hs_match = HsMatch {
            id: PatternId(id),
            start_idx: from as usize,
            end_idx: to as usize,
        };
        match callback(hs_match) {
            ControlFlow::Continue(_) => 0,
            ControlFlow::Break(_) => 1,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::compiler::Pattern;
    use crate::database::BlockDatabase;
    use crate::error::Error;
    use crate::runtime::{ErrorCode, Scratch};
    use crate::scan::HsMatch;
    use std::ops::ControlFlow;

    /// Helper to make equality tests less verbose
    fn as_hs_match(id: u32, start: usize, end: usize) -> HsMatch {
        HsMatch {
            id: id.into(),
            start_idx: start,
            end_idx: end,
        }
    }

    #[test]
    fn test_single_pattern_multi_match() {
        let haystack = "abcdefghijklmabcnopqrstuvacwxyz";
        let expr1 = Pattern::new("ab?c").id(1234).build();
        let mut db = BlockDatabase::try_new([&expr1]).unwrap();
        let scratch = Scratch::try_new_for(&db).unwrap();

        let mut results: Vec<HsMatch> = vec![];
        db.scan(
            &scratch,
            haystack.as_bytes(),
            Box::new(|hs_match| {
                results.push(hs_match);
                ControlFlow::Continue(())
            }),
        )
        .unwrap();

        let mut matches = results.into_iter();
        assert_eq!(matches.next(), Some(as_hs_match(1234, 0, 3)));
        assert_eq!(matches.next(), Some(as_hs_match(1234, 0, 16)));
        assert_eq!(matches.next(), Some(as_hs_match(1234, 0, 27)));
        assert_eq!(matches.next(), None);

        let mut results: Vec<HsMatch> = vec![];
        // Scan again, but this time terminate after the first match
        let scan_res = db
            .scan(
                &scratch,
                haystack.as_bytes(),
                Box::new(|hs_match| {
                    results.push(hs_match);
                    ControlFlow::Break(())
                }),
            )
            .unwrap_err();
        assert!(matches!(
            scan_res,
            Error::Runtime(ErrorCode::SCAN_TERMINATED)
        ));

        let mut matches = results.into_iter();
        assert_eq!(matches.next(), Some(as_hs_match(1234, 0, 3)));
        assert_eq!(matches.next(), None);
    }
}
